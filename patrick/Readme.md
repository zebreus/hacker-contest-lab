1. We obtained the ssh password for user from the git repo.
2. We first decompiled the token scrambler using dogbolt.org . It scrambles the token by first doing a rot 13 to uppercase letters and a rot 5 to numbers. Then it substitutes some lowercase letters with symbols. We choose implementation decompiled with hexrays for both functions. We modified the decompiled code to unscramble the token. The rotations are self-inverse so we didnt need to modify the rotation function. The substitution function was inverted, by inverting the substitution table. See `unscramble.c` for the implementation.
3. The last two tokens look like we should do some binary exploitation. But that turned out to be quite unneccessary, because
4. we were able to read the final two tokens by getting root access to the machine. Even though we didnt have write access to the blockchain.txt file, we were able to delete it, because the directory it was contained in is owned by user. Now we can get a privileged write and create vector to nearly any file, by symlinking `blockchain.txt` to the file we want to write and then using the SUID blockchain binaries to reset the file or append to it. However it proofed quite difficult, to exploit that vector, because all writes are prefixed with `\n` and the first character of every line is a `|`, because the printed output is always surrounded by an asciiart box. This means that we cant use this to write valid entries into `authorized_keys` or `shadow`. However we are able to write to `/etc/ls.so.preload` which contains a list of space-separated libaries that get loaded before the actual binary. The best thing is that this even works for SUID binaries. The code below produces a library that drops us into a root shell. We now can `cat /root/Desktop/token.txt` and `cat /home/patrick/token.txt`. This is a bit of a cheese strategy, but hey, it works. Sadly no binary exploitation today. `rootshell.sh` contains our exploit.

3b. We first tried to do some binary exploitation for the blockchain things. This is how we first obtained the third token. We used the available source and ghidra to get a high-level overview over the binary. Then we identified an exploitable stack overflow in the greeter function. By entering a value longer than 32 byte into the `gets` function, we could overflow the `name_buf` buffer. Because there is no stack protection, we can just overflow and override the return address with the address of the `get_flag_and_win` function. We found the address of the function using gdb (`0x4015b3`). We also used gdb to figure out how far we needed to actually overflow the stack to hit the return address, which resulted in 40bytes and then the return address. So our exploit is `echo -ne $'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\xb3\x15\x40' | ./write_to_blockchain_v1` which prints the token.